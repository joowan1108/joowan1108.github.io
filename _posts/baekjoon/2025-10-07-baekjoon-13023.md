---
layout: single
title: "BOJ 13023 ABCDE"
categories: baekjoon
tag: [그래프 이론, 그래프 탐색, 깊이 우선 탐색, 백트래킹]
author_profile: false
sidebar:
    nav: "counts"
toc: true
toc_sticky: true
toc_label: Table of Contents
use_math: true
---
 
 [문제](https://www.acmicpc.net/problem/13023)

# 접근 방법
a -> b -> c -> d -> e의 경우가 존재하는지 확인하는 것이기 때문에 dfs를 사용해야 한다는 것을 알아냈다. 

Dfs를 하다가 조건을 만족 (times == 4)하게 되면 return True를 하게 되어 그 stack 위에 존재하는 dfs 함수들도 True를 반환하게 만들었다.

여기서 중요한게 어떤 노드를 통해 조건을 만족하는 것이 불가능하다면, 이 노드는 visited에서 빼고 return False를 하여 backtracking을 해야한다. 

1 -> 2,
1-> 3
3->2->5->4
하고 해보자. 1에서 start해서 2로 갔을 때, 2에서는 조건을 만족할 수 없다. 이때 여기서 visited에서 2를 안 빼고 3으로 간다면, 1->3->2->5->4가 가능함에도 이 경우의 수를 확인하지 못한다.

# 정답 코드
``` python
import sys
input = sys.stdin.readline

n,m = map(int, input().split())
graph = [[] for _ in range(n+1)]
for _ in range(m):
  a,b = map(int, input().split())
  graph[a].append(b)
  graph[b].append(a)


visited = set()

def dfs(start, times):
# 재귀 종료 조건
  if times == 4:
    return True
  visited.add(start)
  for adj in graph[start]:
    if adj not in visited:
    # 더 진행했을 때 조건을 만족한다면, stack 내 다른 함수들도 true 반환하도록 함
      if dfs(adj, times+1):
        return True
        
  # 이 노드를 통해 조건을 만족할 수 없다면, backtracking
  visited.discard(start)
  return False

result = False
for i in range(n):
  if graph[i]:
    result = result | dfs(i, 0)
    if result:
      break
if result:
  print(1)
else:
  print(0)
      
``` 


# 느낀 점
이 문제를 통해 재귀함수에 대한 이해도가 높아진 것 같다.
