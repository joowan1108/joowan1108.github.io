---
layout: single
title: "BOJ 1744 수 묶기"
categories: baekjoon
tag: [그리디 알고리즘, 정렬, 많은 조건 분기]
author_profile: false
sidebar:
    nav: "counts"
toc: true
toc_sticky: true
toc_label: Table of Contents
use_math: true
---
 
[문제](https://www.acmicpc.net/problem/1744)

# 접근 방법

양수만 존재했다면 구현이 쉬웠을텐데, 음수와 0이 나와서 더 많은 생각을 해야 했다.

우선 양수끼리 곱했을 때는 1과 곱해지는 것이 아닌 이상 큰 수끼리 곱하는 것이 더 크다.
음수끼리 곱했을 때는 -1과 상관없이 큰 수끼리 곱하는 것이 더 크다.

이런 방법으로 양수와 음수를 2개씩 짝 지으면, 양수 음수 둘다 1개 또는 0개가 남을 것이다. 우선 양수가 하나 남았을 경우에는 그냥 더해야지 이득이다. 음수가 하나 남았을 경우에는 0과 곱해서 0으로 만들어야 한다. 0이 존재하지 않는다면 그냥 더해야 한다. 

이런 식으로 코드를 짜다보면 1과 0들만 남게되는데, 얘네들은 그냥 각각 더해야지 최대값을 구할 수 있다.

이 과정을 구현하면 다음과 같다:

# 정답 코드

``` python

import sys
input = sys.stdin.readline


"""
1과 곱해지는 경우 말고는 axb는 a+b보다 항상 크다. 그리고 수를 큰 것끼리 묶을수록 axb가 커진다. 

음수가 연달아 나올 경우에는 무조건 음수끼리 곱해야 최대가 된다. 그리고 수의 magnitude가 큰 것끼리 묶어야 한다.

그래서 결국 양수(0과 1을 제외)와 음수를 나눠서 풀어야할 것 같다.

짝을 다 나눈 후에, 음수와 0이 남는다면 곱하고, 음수와 1이 남는다면 따로 더해야한다.

음수와 양수가 남는다면 따로 더해야 한다. 0과 양수가 남는다면 따로 더해야 한다.
"""

n = int(input())
result = 0

pos = []
neg = []
zero = []
one = []

for _ in range(n):
  num = int(input())
  if num>1:
    pos.append(num)
  elif num<0:
    neg.append(num)
  elif num == 0:
    zero.append(num)
  else:
    one.append(num)


pos.sort()
neg.sort(reverse=True)

while len(pos)>=2:
  a = pos.pop()
  b = pos.pop()
  result += a*b

# 양수가 1개 남았다면
if pos:
  result += pos.pop()

while len(neg)>=2:
  a = neg.pop()
  b = neg.pop()
  result += a*b

#음수가 한 개 남았을때
if neg:
  #0과 곱해질 수 있다면
  if zero:
    zero.pop()
    neg.pop()
    result += 0

  #1만 있다면
  elif one:
    a = one.pop()
    b = neg.pop()
    result += (a+b)

  #아무것도 없다면
  else:
    result += neg.pop()

  
while one:
  one.pop()
  result+=1

print(result)


```
