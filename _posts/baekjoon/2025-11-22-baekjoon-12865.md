---
layout: single
title: "BOJ 12865 평범한 배낭"
categories: baekjoon
tag: [다이나믹 프로그래밍, 배낭 문제]
author_profile: false
sidebar:
    nav: "counts"
toc: true
toc_sticky: true
toc_label: Table of Contents
use_math: true
---
 
[문제](https://www.acmicpc.net/problem/12865)

# 접근 방법

모든 경우의 수를 확인해야 하는데 너무 복잡하기 때문에 dp를 생각하였다. 이때 각 물품을 한번씩만 담아야된다는 것을 모르고 잘못 풀었다...

한번씩만 담아야하는 상황에서는 무게가 큰 쪽부터 점화식을 진행해야 한다. 앞에서부터 하면 한번씩만 담겨지지가 않는다. 

예를 들어 무게가 3인 물건의 가치가 2일 때, 무게가 6일 때 순방향으로 점화식을 진행하면 무게가 3인 물건을 두번 넣어서 가치가 4인 상황이 발생한다.

뒤에서부터 계산하면, 참조하는 값 dp[i-w]이 이번 물건을 넣기 전의 상태임이 보장되므로 물건을 중복해서 넣지 않게 된다.

# 정답 코드 

``` python
import sys
input = sys.stdin.readline

'''
모든 경우의 수를 봐야하는데 너무 복잡함 -> dp 생각했다

dp 배열의 index는 가방 무게이고 값으로는 그 무게에서 얻을 수 있는 최대 가치가 담긴다.

점화식은 dp[i] = max(dp[i], dp[i-w] + v)
'''

n,k = map(int, input().split())
dp = [0]*(k+1)

pairs = []
for _ in range(n):
  w,v = map(int, input().split())
  pairs.append([w,v])

# 아이템이 중복이 되면 안되기 때문에 아이템을 하나씩 사용해서 dp 배열을 구성해야함
for w,v in pairs:
  for i in range(k,w-1,-1):
    dp[i] = max(dp[i], dp[i - w] + v)


print(dp[k])


```  
