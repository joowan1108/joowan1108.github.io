---
layout: single
title: "BOJ 12865 평범한 배낭"
categories: baekjoon
tag: [다이나믹 프로그래밍, 배낭 문제]
author_profile: false
sidebar:
    nav: "counts"
toc: true
toc_sticky: true
toc_label: Table of Contents
use_math: true
---
 
[문제](https://www.acmicpc.net/problem/12865)

# 접근 방법

정해진 무게 안에서 최대의 가치를 주는 조합을 계산하기 위해서는 모든 경우의 수를 확인해봐야 한다. 하지만, 물건이 N개일 때 전체 조합의 수는 대충 2^N이다. 즉 완전 탐색이 아닌 것이다. 이럴 때는 DP인지 이분 탐색인지, 그리디인지와 같은 고려를 한다.

이분 탐색일 수는 없다. 고려해야 하는 변수가 너무 많다.

그리디도 아니다. 변수끼리 배수 관계가 보장 안 됐고 가치를 큰 것부터 넣는다고 해서 총 가치가 최대가 되는 것이 아니기 때문이다.

따라서, DP라고 결론을 내렸다.

dp[i]를 i의 무게 안에서 최대의 가치가 되도록 설정하면 된다.

물건을 한 번만 담을 수 있기 때문에 중복이 일어나는 상황을 막아야 한다.

어떤 무게에서 시작해서 모든 물건들에 대해 dp[i+w] = max(dp[i], dp[i]+v))을 한다면 무게가 3인 물건을 담아서 dp[3] = v가 된 지점에서 무게가 3인 물건을 한번 더 담게 되어서 dp[6] = max(dp[3], dp[3]+v)가 될 수 있음. 즉 중복이 될 수 있음

따라서 역순으로 dp를 진행해야 한다. 역순으로 진행하면 dp[i] 값 = i에 도달하기 위해 물건 1을 썼을 지점에서 물건 1을 썼을 때를 계산할 수 있음. 즉, 중복이 되지 않는다면 역순으로 해야된다고 생각하면 된다. 

# 정답 코드 

``` python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

goods = []
dp = [0]*(k+1)

for _ in range(n):
  w,v = map(int, input().split())
  goods.append([w,v])

# 물건은 한번에 한번씩만 사용할 수 있음
for w,v in goods:
  for i in range(k, w-1, -1):
    dp[i] = max(dp[i], dp[i-w] + v)

print(max(dp))

```  
